<doctype html>
<html>
<head>
<title>Final project</title>
<script type="text/javascript" src="shaders.js"></script>
<script type="text/javascript" src="obj.js"></script>
<script type="text/javascript" src="objs.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
<link rel="stylesheet" href="style.css">

<script id="initFunctions" type="text/javascript">
///////////////////////////////////////////////////////////////////////////////////
// Below is the core WebGL initialization code.
///////////////////////////////////////////////////////////////////////////////////

var canvas, gl;
var perspectiveMatrix;	
var rotX=0, rotY=0, transY=0, transZ=40;
var MV, MVP;
var verticesArray = [];
var offsetVertices = [];
let isPlaying = false;
let keydownListenerMove;
let keydownListenerSimulate;



// Called once to initialize
function InitWebGL() {	
    canvas = document.getElementById("canvas");
    canvas.oncontextmenu = function() { return false; };
    gl = canvas.getContext("webgl", { antialias: false, depth: true }); // Initialize the GL context
    if (!gl) {
        alert("Unable to initialize WebGL. Your browser or machine may not support it.");
        return;
    }

    gl.clearColor(0, 0, 0, 0);
    gl.enable(gl.DEPTH_TEST);

	skybox = new Skybox();

	InitMassSprings();

    UpdateCanvasSize();
}

function UpdateCanvasSize()
{
	canvas.style.width  = "100%";
	canvas.style.height = "100%";
	const pixelRatio = window.devicePixelRatio || 1;
	canvas.width  = pixelRatio * canvas.clientWidth;
	canvas.height = pixelRatio * canvas.clientHeight;
	const width  = (canvas.width  / pixelRatio);
	const height = (canvas.height / pixelRatio);
	canvas.style.width  = width  + 'px';
	canvas.style.height = height + 'px';
	gl.viewport( 0, 0, canvas.width, canvas.height );
	UpdateProjectionMatrix();
}

function GetModelViewMatrix( translationX, translationY, translationZ, rotationX, rotationY )
{
	// [TO-DO] Modify the code below to form the transformation matrix.
    let transl = [
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        translationX, translationY, translationZ, 1
    ];
    let rotX = [
        1, 0, 0, 0,
        0, Math.cos(rotationX), Math.sin(rotationX), 0,
        0, -Math.sin(rotationX), Math.cos(rotationX), 0,
        0, 0, 0, 1
	];
    let rotY = [
        Math.cos(rotationY), 0, -Math.sin(rotationY), 0,
        0, 1, 0, 0,
        Math.sin(rotationY), 0, Math.cos(rotationY), 0,
        0, 0, 0, 1
	];

    let res = MatrixMult(rotY, rotX);
    res = MatrixMult(transl, res);
    return res;
}

function UpdateProjectionMatrix()
{

	const fov = 60;
    var r = canvas.width / canvas.height;
    var n = (transZ - 10.0);  // Sposta il near plane più lontano per evitare il clipping vicino
    const min_n = 0.001;
    if ( n < min_n ) n = min_n;
    var f = (transZ + 1000.0); // Sposta il far plane molto più lontano per includere oggetti distanti
    var ff = 3.145 * fov / 180;  // Da gradi in radianti
    var s = 1 / Math.tan( ff/2 );
    perspectiveMatrix = [
        s/r, 0, 0, 0,
        0, s, 0, 0,
        0, 0, (n+f)/(f-n), 1,
        0, 0, -2*n*f/(f-n), 0
    ];	
	MV  = GetModelViewMatrix( 0, transY, transZ, rotX, rotY );
	MVP = MatrixMult( perspectiveMatrix, MV );
}

function getTrans() {
    let worldToCam = GetModelViewMatrix(0, transY, transZ, rotX, rotY);
    let camToWorld = mat4.create(); // Create an empty matrix for camToWorld

    mat4.invert(camToWorld, worldToCam); // Invert worldToCam to get camToWorld

    return {
        camToWorld: camToWorld,
        worldToCam: worldToCam,
    };
}

// This is the main function that handled WebGL drawing
function DrawScene() {
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

	var trans = getTrans();
	
	skybox.draw(trans);
	
	for (let i = 0; i < massSprings.length; i++) {
		let massSpring = massSprings[i];
		if (massSpring && massSpring.meshDrawer) {
			UpdateProjectionMatrix();
			let MV = GetModelViewMatrix(0, transY, transZ, rotX, rotY);
			let MVP = MatrixMult(perspectiveMatrix, MV);
			let nrmTrans = [MV[0], MV[1], MV[2], MV[4], MV[5], MV[6], MV[8], MV[9], MV[10]];

			massSpring.meshDrawer.draw(MVP, MV, nrmTrans);
		} else {
			console.warn(`massSpring[${i}] or its meshDrawer is undefined`);
		}
	}	
}

function InitMassSprings() {
    const pinDistance = 20;  // Distanza laterale tra i birilli
    const rowDistance = 30;  // Distanza tra le file di birilli
    const initialX = 0;      // Posizione iniziale della prima fila
    const initialZ = 100;    // Posizione iniziale della prima fila, spostata indietro rispetto alla palla
    const pinHeight = 0;     // Altezza dei birilli sopra il pavimento

    let bowlingBall = new Ball(ballObj, new Vec3(initialX, pinHeight, initialZ - 300));
    let floor = new Floor(floorObj, new Vec3(0, 0, -1));
    let pin1 = new Pin(pinObj, new Vec3(initialX, pinHeight, initialZ)); 
    let pin2 = new Pin(pinObj, new Vec3(initialX - pinDistance, pinHeight, initialZ + rowDistance));
    let pin3 = new Pin(pinObj, new Vec3(initialX + pinDistance, pinHeight, initialZ + rowDistance));
    let pin4 = new Pin(pinObj, new Vec3(initialX - 2 * pinDistance, pinHeight, initialZ + 2 * rowDistance));
    let pin5 = new Pin(pinObj, new Vec3(initialX, pinHeight, initialZ + 2 * rowDistance));
    let pin6 = new Pin(pinObj, new Vec3(initialX + 2 * pinDistance, pinHeight, initialZ + 2 * rowDistance));
    let pin7 = new Pin(pinObj, new Vec3(initialX - 3 * pinDistance, pinHeight, initialZ + 3 * rowDistance));
    let pin8 = new Pin(pinObj, new Vec3(initialX - pinDistance, pinHeight, initialZ + 3 * rowDistance));
    let pin9 = new Pin(pinObj, new Vec3(initialX + pinDistance, pinHeight, initialZ + 3 * rowDistance));
    let pin10 = new Pin(pinObj, new Vec3(initialX + 3 * pinDistance, pinHeight, initialZ + 3 * rowDistance));

    massSprings.push(floor);
    massSprings.push(pin1);
    massSprings.push(pin2);
    massSprings.push(pin3);
    massSprings.push(pin4);
    massSprings.push(pin5);
    massSprings.push(pin6);
    massSprings.push(pin7);
    massSprings.push(pin8);
    massSprings.push(pin9);
    massSprings.push(pin10);
    massSprings.push(bowlingBall);

    // Texture per gli oggetti
    LoadTexturesForObjects(massSprings);
}

function InitShaderProgram( vsSource, fsSource, wgl=gl )
{
	const vs = CompileShader( wgl.VERTEX_SHADER,   vsSource, wgl );
	const fs = CompileShader( wgl.FRAGMENT_SHADER, fsSource, wgl );

	const prog = wgl.createProgram();
	wgl.attachShader(prog, vs);
	wgl.attachShader(prog, fs);
	wgl.linkProgram(prog);

	if (!wgl.getProgramParameter(prog, wgl.LINK_STATUS)) {
		alert('Unable to initialize the shader program: ' + wgl.getProgramInfoLog(prog));
		return null;
	}
	return prog;
}

// This is a helper function for compiling a shader, called by InitShaderProgram().
function CompileShader( type, source, wgl=gl )
{
	const shader = wgl.createShader(type);
	wgl.shaderSource(shader, source);
	wgl.compileShader(shader);
	if (!wgl.getShaderParameter( shader, wgl.COMPILE_STATUS) ) {
		alert('An error occurred compiling shader:\n' + wgl.getShaderInfoLog(shader));
		wgl.deleteShader(shader);
		return null;
	}
	return shader;
}

// Multiplies two matrices and returns the result A*B.
// The arguments A and B are arrays, representing column-major matrices.
function MatrixMult( A, B )
{
	var C = Array(16);
	for ( var i=0, m=0; i<4; ++i ) {
		for ( var j=0; j<4; ++j, ++m ) {
			var v = 0;
			for ( var k=0; k<4; ++k ) {
				v += A[j+4*k] * B[k+4*i];
			}
			C[m] = v;
		}
	}
	return C;
}

// Returns the inverse of the given 4x4 matrix
function MatrixInverse( m )
{
	var r = Array(16);
	
	var v_11_14__10_15 = m[11] * m[14] - m[10] * m[15];
	var v_10_15__11_14 = m[10] * m[15] - m[11] * m[14];
	var v__7_14___6_15 = m[ 7] * m[14] - m[ 6] * m[15];
	var v__6_11___7_10 = m[ 6] * m[11] - m[ 7] * m[10];

	var v__9_15__11_13 = m[ 9] * m[15] - m[11] * m[13];
	var v_11_13___9_15 = m[11] * m[13] - m[ 9] * m[15];
	var v__5_15___7_13 = m[ 5] * m[15] - m[ 7] * m[13];
	var v__7__9___5_11 = m[ 7] * m[ 9] - m[ 5] * m[11];
	
	var v_10_13___9_14 = m[10] * m[13] - m[ 9] * m[14];
	var v__9_14__10_13 = m[ 9] * m[14] - m[10] * m[13];
	var v__6_13___5_14 = m[ 6] * m[13] - m[ 5] * m[14];
	var v__5_10___6__9 = m[ 5] * m[10] - m[ 6] * m[ 9];
	
	var v_11_12___8_15 = m[11] * m[12] - m[ 8] * m[15];
	var v__8_15__11_12 = m[ 8] * m[15] - m[11] * m[12];
	var v__7_12___4_15 = m[ 7] * m[12] - m[ 4] * m[15];
	var v__4_11___7__8 = m[ 4] * m[11] - m[ 7] * m[ 8];
	
	var v__8_14__10_12 = m[ 8] * m[14] - m[10] * m[12];
	var v_10_12___8_14 = m[10] * m[12] - m[ 8] * m[14];
	var v__4_14___6_12 = m[ 4] * m[14] - m[ 6] * m[12];
	var v__6__8___4_10 = m[ 6] * m[ 8] - m[ 4] * m[10];
	
	var v__9_12___8_13 = m[ 9] * m[12] - m[ 8] * m[13];
	var v__8_13___9_12 = m[ 8] * m[13] - m[ 9] * m[12];
	var v__5_12___4_13 = m[ 5] * m[12] - m[ 4] * m[13];
	var v__4__9___5__8 = m[ 4] * m[ 9] - m[ 5] * m[ 8];

	r[ 0] = m[5] * (-v_11_14__10_15) + m[6] * (-v__9_15__11_13) + m[7] * (-v_10_13___9_14);
	r[ 1] = m[1] * (-v_10_15__11_14) + m[2] * (-v_11_13___9_15) + m[3] * (-v__9_14__10_13);
	r[ 2] = m[1] * (-v__7_14___6_15) + m[2] * (-v__5_15___7_13) + m[3] * (-v__6_13___5_14);
	r[ 3] = m[1] * (-v__6_11___7_10) + m[2] * (-v__7__9___5_11) + m[3] * (-v__5_10___6__9);
	
	r[ 4] = m[4] * ( v_11_14__10_15) + m[6] * (-v_11_12___8_15) + m[7] * (-v__8_14__10_12);
	r[ 5] = m[0] * ( v_10_15__11_14) + m[2] * (-v__8_15__11_12) + m[3] * (-v_10_12___8_14);
	r[ 6] = m[0] * ( v__7_14___6_15) + m[2] * (-v__7_12___4_15) + m[3] * (-v__4_14___6_12);
	r[ 7] = m[0] * ( v__6_11___7_10) + m[2] * (-v__4_11___7__8) + m[3] * (-v__6__8___4_10);
	
	r[ 8] = m[4] * ( v__9_15__11_13) + m[5] * ( v_11_12___8_15) + m[7] * (-v__9_12___8_13);
	r[ 9] = m[0] * ( v_11_13___9_15) + m[1] * ( v__8_15__11_12) + m[3] * (-v__8_13___9_12);
	r[10] = m[0] * ( v__5_15___7_13) + m[1] * ( v__7_12___4_15) + m[3] * (-v__5_12___4_13);
	r[11] = m[0] * ( v__7__9___5_11) + m[1] * ( v__4_11___7__8) + m[3] * (-v__4__9___5__8);

	r[12] = m[4] * ( v_10_13___9_14) + m[5] * ( v__8_14__10_12) + m[6] * ( v__9_12___8_13);
	r[13] = m[0] * ( v__9_14__10_13) + m[1] * ( v_10_12___8_14) + m[2] * ( v__8_13___9_12);
	r[14] = m[0] * ( v__6_13___5_14) + m[1] * ( v__4_14___6_12) + m[2] * ( v__5_12___4_13);
	r[15] = m[0] * ( v__5_10___6__9) + m[1] * ( v__6__8___4_10) + m[2] * ( v__4__9___5__8);

	var det = m[0]*r[0] + m[1]*r[4] + m[2]*r[8] + m[3]*r[12];
	for ( var i=0; i<16; ++i ) r[i] /= det;
	
	return r;
}

///////////////////////////////////////////////////////////////////////////////////
</script>


<script id="meshDrawer" type="text/javascript">
///////////////////////////////////////////////////////////////////////////////////
// Below is the mesh drawer code
///////////////////////////////////////////////////////////////////////////////////
class MeshDrawer
{
	constructor()
	{
		this.prog = InitShaderProgram( meshVS, meshFS );
        
		this.mvp = gl.getUniformLocation(this.prog, 'u_mvp');
        this.matrixMVLoc = gl.getUniformLocation(this.prog, "u_mv");
        this.matrixNormalLoc = gl.getUniformLocation(this.prog, "u_mn");
		this.shininessLoc = gl.getUniformLocation(this.prog, "u_shininess");
		this.lightDirectionLoc = gl.getUniformLocation(this.prog, "u_lightDirection");
		this.useTextureLoc = gl.getUniformLocation(this.prog, 'u_useTexture');
		this.textureLoc = gl.getUniformLocation(this.prog, 'u_texture');
		
        this.vertPos = gl.getAttribLocation(this.prog, 'a_pos');
        this.texPos = gl.getAttribLocation(this.prog, 'a_texCoord');
        this.normalLocation = gl.getAttribLocation(this.prog, "a_normal");
		
		this.texture = gl.createTexture();
        this.vertexBuffer = gl.createBuffer();
        this.texelsBuffer = gl.createBuffer();
        this.normalBuffer = gl.createBuffer();
		
        this.numTriangles = 0;
	}
	setMesh(vertPos, texCoords, normals) {

		verticesArray.push(vertPos);
		offsetVertices.push(vertPos.length);
		
		if (!this.vertexBuffer) {
			this.vertexBuffer = gl.createBuffer();
		}
		gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertPos), gl.STATIC_DRAW);

		if (!this.texelsBuffer) {
			this.texelsBuffer = gl.createBuffer();
		}
		gl.bindBuffer(gl.ARRAY_BUFFER, this.texelsBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.STATIC_DRAW);

		if (!this.normalBuffer) {
			this.normalBuffer = gl.createBuffer();
		}
		gl.bindBuffer(gl.ARRAY_BUFFER, this.normalBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
		
		this.numTriangles = vertPos.length / 3;
	}
	draw( matrixMVP, matrixMV, matrixNormal )
	{
		gl.useProgram(this.prog);

        gl.uniformMatrix4fv(this.mvp, false, matrixMVP);
        gl.uniformMatrix4fv(this.matrixMVLoc, false, matrixMV);
        gl.uniformMatrix3fv(this.matrixNormalLoc, false, matrixNormal);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.enableVertexAttribArray(this.vertPos);
        gl.vertexAttribPointer(this.vertPos, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this.texelsBuffer);
        gl.enableVertexAttribArray(this.texPos);
        gl.vertexAttribPointer(this.texPos, 2, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this.normalBuffer);
        gl.enableVertexAttribArray(this.normalLocation);
        gl.vertexAttribPointer(this.normalLocation, 3, gl.FLOAT, false, 0, 0);

        gl.drawArrays(gl.TRIANGLES, 0, this.numTriangles * 3);
	}
	setTexture( img )
	{   
        if (!this.texture) {
            this.texture = gl.createTexture();  
		}

        gl.bindTexture(gl.TEXTURE_2D, this.texture);

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, img);

        gl.generateMipmap(gl.TEXTURE_2D);

        gl.useProgram(this.prog);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.uniform1i(this.textureLoc, 0);
	}
	showTexture( show )
	{
		gl.useProgram(this.prog);
        gl.uniform1i(this.useTextureLoc, show);
	}
    setLightDir(x, y, z) {
        // [TO-DO] set the uniform parameter(s) of the fragment shader to specify the light direction.
        gl.useProgram(this.prog);
        gl.uniform3fv(this.lightDirectionLoc, [x, y, z]);
    }
    setShininess(shininess) {
        // [TO-DO] set the uniform parameter(s) of the fragment shader to specify the shininess.
        gl.useProgram(this.prog);
        gl.uniform1f(this.shininessLoc, shininess);
    }
}

</script>

<script id="background" type="text/javascript">
///////////////////////////////////////////////////////////////////////////////////
// Background
///////////////////////////////////////////////////////////////////////////////////

class Skybox 
{
	constructor()
	{
		this.prog = InitShaderProgram( SkyVS, SkyFS );
		if (!this.prog) {
			console.error('Failed to initialize shader program');
			return;
		}
		this.positionLocation = gl.getAttribLocation(this.prog, "a_position");
		this.skyboxLocation = gl.getUniformLocation(this.prog, "u_skybox");
		this.viewDirectionProjectionInverseLocation = gl.getUniformLocation(this.prog, "u_viewDirectionProjectionInverse");
		
		this.positionBuffer = gl.createBuffer();
		var positions = new Float32Array([
			-1, -1,
			1, -1,
			-1,  1,
			-1,  1,
			1, -1,
			1,  1,
		]);
		gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

		// Create and configure the texture
		this.texture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);

		const faceInfos = [
			{ target: gl.TEXTURE_CUBE_MAP_POSITIVE_X, url: 'SkyTextures/right.jpg' },
			{ target: gl.TEXTURE_CUBE_MAP_NEGATIVE_X, url: 'SkyTextures/left.jpg' },
			{ target: gl.TEXTURE_CUBE_MAP_POSITIVE_Y, url: 'SkyTextures/up.jpg' },
			{ target: gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, url: 'SkyTextures/down.jpg' },
			{ target: gl.TEXTURE_CUBE_MAP_POSITIVE_Z, url: 'SkyTextures/front.jpg' },
			{ target: gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, url: 'SkyTextures/back.jpg' },
		];

		faceInfos.forEach((faceInfo) => {
			const {target, url} = faceInfo;

			const level = 0;
			const internalFormat = gl.RGBA;
			const width = 512;
			const height = 512;
			const format = gl.RGBA;
			const type = gl.UNSIGNED_BYTE;

			gl.texImage2D(target, level, internalFormat, width, height, 0, format, type, null);

			const image = new Image();
			image.crossOrigin = "anonymous";
			image.src = url;
			image.addEventListener('load', () => {
				gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
				gl.texImage2D(target, level, internalFormat, format, type, image);
				gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
			});
		});

		gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
	    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);

	}
	draw(trans)
	{
		// Compute viewDirectionProjectionInverseMatrix
		UpdateProjectionMatrix();
		let viewDirectionProjectionMatrix = mat4.create();
		mat4.multiply(viewDirectionProjectionMatrix, perspectiveMatrix, trans.worldToCam);

		let viewDirectionProjectionInverseMatrix = mat4.create();
		mat4.invert(viewDirectionProjectionInverseMatrix, viewDirectionProjectionMatrix);

		// Set up the program and bind buffers
		gl.useProgram(this.prog);
		gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);

		// Configure the position attribute
		gl.enableVertexAttribArray(this.positionLocation);
		gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, 0, 0);

		// Set the uniforms
		gl.uniformMatrix4fv(this.viewDirectionProjectionInverseLocation, false, viewDirectionProjectionInverseMatrix);
		gl.uniform1i(this.skyboxLocation, 0);

		// Set the depth function and draw the skybox
		gl.depthFunc(gl.LEQUAL);
		gl.drawArrays(gl.TRIANGLES, 0, 6);
	}

}
</script>

<script id="mass-spring system" type="text/javascript">
///////////////////////////////////////////////////////////////////////////////////
// Below is the mass-spring system code
///////////////////////////////////////////////////////////////////////////////////
var massSprings = [];
var boundingBoxes = [];

class Vec3 {
	constructor( x, y, z ) { this.init(x,y,z); }
	init( x, y, z ) { this.x=x; this.y=y; this.z=z; }
	copy ( ) { return new Vec3( this.x, this.y, this.z ); }
	set  (v) { this.x =v.x; this.y =v.y; this.z =v.z; }
	inc  (v) { this.x+=v.x; this.y+=v.y; this.z+=v.z; }
	dec  (v) { this.x-=v.x; this.y-=v.y; this.z-=v.z; }
	scale(f) { this.x*=f; this.y*=f; this.z*=f; }
	add  (v) { return new Vec3( this.x+v.x, this.y+v.y, this.z+v.z ); }
	sub  (v) { return new Vec3( this.x-v.x, this.y-v.y, this.z-v.z ); }
	dot  (v) { return this.x*v.x + this.y*v.y + this.z*v.z; }
	cross(v) { return new Vec3( this.y*v.z-this.z*v.y, this.z*v.x-this.x*v.z, this.x*v.y-this.y*v.x ); }
	mul  (f) { return new Vec3( this.x*f, this.y*f, this.z*f ); }
	div  (f) { return new Vec3( this.x/f, this.y/f, this.z/f ); }
	len2 ( ) { return this.dot(this); }
	len  ( ) { return Math.sqrt(this.len2()); }
	unit ( ) { return this.div(this.len()); }
	normalize() {
		var l = this.len();
		this.x /= l;
		this.y /= l;
		this.z /= l;
	}
	trans(m) {
		return {
			x: m[0]*this.x + m[4]*this.y + m[ 8]*this.z + m[12],
			y: m[1]*this.x + m[5]*this.y + m[ 9]*this.z + m[13],
			z: m[2]*this.x + m[6]*this.y + m[10]*this.z + m[14],
			w: m[3]*this.x + m[7]*this.y + m[11]*this.z + m[15]
		};
	}
}

function ToVec3(a) { return new Vec3(a[0],a[1],a[2]); }


function SimTimeStep(dt, positions, velocities, springs, stiffness, damping, particleMass, gravity, restitution, flagcollision, boundingBoxes) 
{
    // console.log("SimTimeStep")
    var forces = new Array(positions.length);
    for (var i = 0; i < forces.length; ++i) forces[i] = new Vec3(0, 0, 0);

    for (var i = 0; i < positions.length; i++) {
        forces[i] = forces[i].add(gravity.mul(particleMass));
    }
    
    // Molla
    for (var i = 0; i < springs.length; i++) {
        let pos0 = positions[springs[i].p0];
        let pos1 = positions[springs[i].p1];
        let vel0 = velocities[springs[i].p0];
        let vel1 = velocities[springs[i].p1];
        let displacement = pos1.sub(pos0);

        let direction = displacement.unit();

        let stretch = displacement.len() - springs[i].rest;
        let relativeVelocity = vel1.sub(vel0);
        
        let Fs = direction.mul(stretch * stiffness);
        let Fd = direction.mul(relativeVelocity.dot(direction) * damping);

        forces[springs[i].p0] = forces[springs[i].p0].add(Fs.add(Fd));
        forces[springs[i].p1] = forces[springs[i].p1].sub(Fs.add(Fd));
    }

    // Gestione delle collisioni con il suolo
    for (var i = 0; i < positions.length; i++) {
        if (positions[i].y < 0) {
            positions[i].y = 0;
            velocities[i].y *= -restitution;
        }

        if (positions[i].y == 0) {
            velocities[i].x *= 0.90;
            velocities[i].z *= 0.90;
        }

    }

    if (flagcollision) {

        for (let b = 0; b < boundingBoxes.length; b++) {
            let boxB = boundingBoxes[b];
            for (let i = 0; i < positions.length; i++) {

                if (positions[i].x >= boxB.min.x && positions[i].x <= boxB.max.x &&
                    positions[i].y >= boxB.min.y && positions[i].y <= boxB.max.y &&
                    positions[i].z >= boxB.min.z && positions[i].z <= boxB.max.z) {
                        
                    let initialMomentum = velocities[i].mul(particleMass);

                    let distToMinX = positions[i].x - boxB.min.x;
                    let distToMaxX = boxB.max.x - positions[i].x;
                
                    let distToMinY = positions[i].y - boxB.min.y;
                    let distToMaxY = boxB.max.y - positions[i].y;
                
                    let distToMinZ = positions[i].z - boxB.min.z;
                    let distToMaxZ = boxB.max.z - positions[i].z;
                
                    // Asse minore da dove è avvenuta la collisione
                    let minDistX = Math.min(distToMinX, distToMaxX);
                    let minDistY = Math.min(distToMinY, distToMaxY);
                    let minDistZ = Math.min(distToMinZ, distToMaxZ);
                
                    if (minDistX <= minDistY && minDistX <= minDistZ) {
                        if (distToMinX < distToMaxX) {
                            positions[i].x = boxB.min.x - 0.001;
                        } else {
                            positions[i].x = boxB.max.x + 0.001;
                        }
                        velocities[i].x *= -restitution;
                    } else if (minDistY <= minDistX && minDistY <= minDistZ) {
                        if (distToMinY < distToMaxY) {
                            positions[i].y = boxB.min.y - 0.001;
                        } else {
                            positions[i].y = boxB.max.y + 0.001;
                        }
                        velocities[i].y *= -restitution;
                    } else {
                        if (distToMinZ < distToMaxZ) {
                            positions[i].z = boxB.min.z - 0.001;
                        } else {
                            positions[i].z = boxB.max.z + 0.001;
                        }
                        velocities[i].z *= -restitution;
                    }                
                    
                    let finalMomentum = velocities[i].mul(particleMass);

                    let impulse = finalMomentum.sub(initialMomentum);

                    let dampingFactor = 0.85; 
                    impulse = impulse.mul(dampingFactor);

                    forces[i] = forces[i].add(impulse.div(dt));
                }
            }
        }
    }
    
    for (var i = 0; i < positions.length; i++) {
        let acc = forces[i].div(particleMass);
        velocities[i] = velocities[i].add(acc.mul(dt));
        positions[i] = positions[i].add(velocities[i].mul(dt));
    }
}

function SimTimeStep_Verlet(dt, positions, prevPositions, velocities, springs, stiffness, damping, particleMass, gravity, restitution, flagcollision, boundingBoxes) 
{
	// console.log("SimTimeStep_Verlet");
    var forces = new Array(positions.length);
    for (var i = 0; i < forces.length; ++i) forces[i] = new Vec3(0, 0, 0);

    // Gravità
    for (var i = 0; i < positions.length; i++) {
        forces[i] = forces[i].add(gravity.mul(particleMass));
    }
    
    // Molle
    for (var i = 0; i < springs.length; i++) {
        let pos0 = positions[springs[i].p0];
        let pos1 = positions[springs[i].p1];
        let vel0 = velocities[springs[i].p0];
        let vel1 = velocities[springs[i].p1];
        let displacement = pos1.sub(pos0);

        let direction = displacement.unit();
        let stretch = displacement.len() - springs[i].rest;
        let relativeVelocity = vel1.sub(vel0);
        
        let Fs = direction.mul(stretch * stiffness);
        let Fd = direction.mul(relativeVelocity.dot(direction) * damping);

        forces[springs[i].p0] = forces[springs[i].p0].add(Fs.add(Fd));
        forces[springs[i].p1] = forces[springs[i].p1].sub(Fs.add(Fd));
    }

    // Gestione delle collisioni con il suolo
    for (var i = 0; i < positions.length; i++) {
        if (positions[i].y < 0) {
            positions[i].y = 0;
            velocities[i].y *= -restitution;
        }

        if (positions[i].y == 0) {
            velocities[i].x *= 0.90;
            velocities[i].z *= 0.90;
        }
    }

    // Gestione delle collisioni con le bounding box
    if (flagcollision) {
        for (let b = 0; b < boundingBoxes.length; b++) {
            let boxB = boundingBoxes[b];
            for (let i = 0; i < positions.length; i++) {
                if (positions[i].x >= boxB.min.x && positions[i].x <= boxB.max.x &&
                    positions[i].y >= boxB.min.y && positions[i].y <= boxB.max.y &&
                    positions[i].z >= boxB.min.z && positions[i].z <= boxB.max.z) {
                        
                    let initialMomentum = velocities[i].mul(particleMass);

                    let distToMinX = positions[i].x - boxB.min.x;
                    let distToMaxX = boxB.max.x - positions[i].x;
                
                    let distToMinY = positions[i].y - boxB.min.y;
                    let distToMaxY = boxB.max.y - positions[i].y;
                
                    let distToMinZ = positions[i].z - boxB.min.z;
                    let distToMaxZ = boxB.max.z - positions[i].z;
                
                    let minDistX = Math.min(distToMinX, distToMaxX);
                    let minDistY = Math.min(distToMinY, distToMaxY);
                    let minDistZ = Math.min(distToMinZ, distToMaxZ);
                
                    if (minDistX <= minDistY && minDistX <= minDistZ) {
                        if (distToMinX < distToMaxX) {
                            positions[i].x = boxB.min.x - 0.001;
                        } else {
                            positions[i].x = boxB.max.x + 0.001;
                        }
                        velocities[i].x *= -restitution;
                    } else if (minDistY <= minDistX && minDistY <= minDistZ) {
                        if (distToMinY < distToMaxY) {
                            positions[i].y = boxB.min.y - 0.001;
                        } else {
                            positions[i].y = boxB.max.y + 0.001;
                        }
                        velocities[i].y *= -restitution;
                    } else {
                        if (distToMinZ < distToMaxZ) {
                            positions[i].z = boxB.min.z - 0.001;
                        } else {
                            positions[i].z = boxB.max.z + 0.001;
                        }
                        velocities[i].z *= -restitution;
                    }

                    let finalMomentum = velocities[i].mul(particleMass);
                    let impulse = finalMomentum.sub(initialMomentum);

                    let dampingFactor = 0.85; 
                    impulse = impulse.mul(dampingFactor);

                    forces[i] = forces[i].add(impulse.div(dt));
                }
            }
        }
    }
    
    // Aggiornamento posizioni utilizzando Verlet Integration
    for (var i = 0; i < positions.length; i++) {
        let acc = forces[i].div(particleMass);  // Calcolo dell'accelerazione

        // Nuova posizione basata su Verlet Integration
        let tempPosition = positions[i];  // Memorizziamo la posizione attuale per usarla come "prevPosition" nel passo successivo
        positions[i] = positions[i].mul(2).sub(prevPositions[i]).add(acc.mul(dt * dt));  // Verlet formula
        prevPositions[i] = tempPosition;  // Aggiorniamo la vecchia posizione
    }
}

function SimTimeStep_ImplicitEuler(dt, positions, velocities, springs, stiffness, damping, particleMass, gravity, restitution, flagcollision, boundingBoxes) 
{

	// console.log("SimTimeStep_ImplicitEuler");
	var forces = new Array(positions.length);
	for (var i = 0; i < forces.length; ++i) forces[i] = new Vec3(0, 0, 0);

	// Gravità
	for (var i = 0; i < positions.length; i++) {
		forces[i] = forces[i].add(gravity.mul(particleMass));
	}

	// Molle
	for (var i = 0; i < springs.length; i++) {
		let pos0 = positions[springs[i].p0];
		let pos1 = positions[springs[i].p1];
		let vel0 = velocities[springs[i].p0];
		let vel1 = velocities[springs[i].p1];
		let displacement = pos1.sub(pos0);

		let direction = displacement.unit();
		let stretch = displacement.len() - springs[i].rest;
		let relativeVelocity = vel1.sub(vel0);

		let Fs = direction.mul(stretch * stiffness);
		let Fd = direction.mul(relativeVelocity.dot(direction) * damping);

		forces[springs[i].p0] = forces[springs[i].p0].add(Fs.add(Fd));
		forces[springs[i].p1] = forces[springs[i].p1].sub(Fs.add(Fd));
	}

	// Collisioni con il suolo
	for (var i = 0; i < positions.length; i++) {
		if (positions[i].y < 0) {
			positions[i].y = 0;
			velocities[i].y *= -restitution;
		}

		if (positions[i].y == 0) {
			velocities[i].x *= 0.90;
			velocities[i].z *= 0.90;
		}
	}

	// Gestione delle collisioni con le bounding box
	if (flagcollision) {
		for (let b = 0; b < boundingBoxes.length; b++) {
			let boxB = boundingBoxes[b];
			for (let i = 0; i < positions.length; i++) {
				if (positions[i].x >= boxB.min.x && positions[i].x <= boxB.max.x &&
					positions[i].y >= boxB.min.y && positions[i].y <= boxB.max.y &&
					positions[i].z >= boxB.min.z && positions[i].z <= boxB.max.z) {
						
					let initialMomentum = velocities[i].mul(particleMass);

					let distToMinX = positions[i].x - boxB.min.x;
					let distToMaxX = boxB.max.x - positions[i].x;
				
					let distToMinY = positions[i].y - boxB.min.y;
					let distToMaxY = boxB.max.y - positions[i].y;
				
					let distToMinZ = positions[i].z - boxB.min.z;
					let distToMaxZ = boxB.max.z - positions[i].z;
				
					let minDistX = Math.min(distToMinX, distToMaxX);
					let minDistY = Math.min(distToMinY, distToMaxY);
					let minDistZ = Math.min(distToMinZ, distToMaxZ);
				
					if (minDistX <= minDistY && minDistX <= minDistZ) {
						if (distToMinX < distToMaxX) {
							positions[i].x = boxB.min.x - 0.001;
						} else {
							positions[i].x = boxB.max.x + 0.001;
						}
						velocities[i].x *= -restitution;
					} else if (minDistY <= minDistX && minDistY <= minDistZ) {
						if (distToMinY < distToMaxY) {
							positions[i].y = boxB.min.y - 0.001;
						} else {
							positions[i].y = boxB.max.y + 0.001;
						}
						velocities[i].y *= -restitution;
					} else {
						if (distToMinZ < distToMaxZ) {
							positions[i].z = boxB.min.z - 0.001;
						} else {
							positions[i].z = boxB.max.z + 0.001;
						}
						velocities[i].z *= -restitution;
					}

					let finalMomentum = velocities[i].mul(particleMass);
					let impulse = finalMomentum.sub(initialMomentum);

					let dampingFactor = 0.85; 
					impulse = impulse.mul(dampingFactor);

					forces[i] = forces[i].add(impulse.div(dt));
				}
			}
		}
	}

	// Aggiornamento delle velocità e delle posizioni utilizzando Euler implicito
	for (var i = 0; i < positions.length; i++) {
		// Calcoliamo l'accelerazione basata sulle forze attuali
		let acc = forces[i].div(particleMass);

		// Aggiorniamo le velocità in modo implicito
		velocities[i] = velocities[i].add(acc.mul(dt));  // v_new = v_old + dt * a(x_new)
		
		// Aggiorniamo le posizioni basandoci sulle nuove velocità
		positions[i] = positions[i].add(velocities[i].mul(dt));  // x_new = x_old + dt * v_new
	}
}


class MassSpring {

	constructor(objdef, initialPosition = new Vec3(0,0,0))
	{
		this.meshDrawer = new MeshDrawer();
		this.gravity = new Vec3( 0, -2.0, 0 );
		this.mass = .1;
		this.stiffness = 1;
		this.damping = 1;
		this.restitution = .8;
		this.initialPosition = initialPosition;
		this.setMesh( objdef );
	}
	setMesh( objdef )
	{
		this.mesh = new ObjMesh;
		this.mesh.parse( objdef );
		var box = this.mesh.getBoundingBox();
		var shift = [
			this.initialPosition.x,
			this.initialPosition.y,
			this.initialPosition.z
		];
		var size = [
			(box.max[0]-box.min[0])/2,
			(box.max[1]-box.min[1])/2,
			(box.max[2]-box.min[2])/2
		];
		var maxSize = Math.max( size[0], size[1], size[2] );
		var scale = 0.4/maxSize;
        if (this instanceof Floor) {
			scale = 0.9;
		}
		this.mesh.shiftAndScale( shift, scale );
		this.mesh.computeNormals();
		this.reset();
		this.initSprings();
		DrawScene();
	}
	initSprings()
	{
		this.springs = [];
		for ( var i=0; i<this.pos.length; ++i ) {
			for ( var j=i+1; j<this.pos.length; ++j ) {
				var r = this.pos[i].sub(this.pos[j]).len();
				if ( r > .02 ) 
				{
					this.springs.push( { p0:i, p1:j, rest:r } );
				}
			}
		}
	}
	reset()
	{
		this.pos = Array( this.mesh.vpos.length );
		for ( var i=0; i<this.pos.length; ++i ) this.pos[i] = ToVec3( this.mesh.vpos[i] );
		this.prevPos = Array( this.mesh.vpos.length );
		for ( var i=0; i<this.prevPos.length; ++i ) this.prevPos[i] = ToVec3( this.mesh.vpos[i] );
		this.vel = Array( this.pos.length );
		for ( var i=0; i<this.vel.length; ++i ) this.vel[i] = new Vec3(0,0,0);
		this.nrm = Array( this.mesh.norm.length );
		for ( var i=0; i<this.nrm.length; ++i ) this.nrm[i] = ToVec3( this.mesh.norm[i] );
		this.buffers = this.mesh.getVertexBuffers();
		this.meshDrawer.setMesh( this.buffers.positionBuffer, this.buffers.texCoordBuffer, this.buffers.normalBuffer );
	}
	currentBoundingBox()
	{
    	let min = new Vec3(Infinity,Infinity,Infinity);
    	let max = new Vec3(-Infinity,-Infinity,-Infinity);
		for (let i = 0; i < this.pos.length; i++) {
			min.x = Math.min(min.x, this.pos[i].x);
			min.y = Math.min(min.y, this.pos[i].y);
			min.z = Math.min(min.z, this.pos[i].z);
			max.x = Math.max(max.x, this.pos[i].x);
			max.y = Math.max(max.y, this.pos[i].y);
			max.z = Math.max(max.z, this.pos[i].z);
		}
		return { min: min, max: max };
	}
	updateMesh()
	{
		function updateBuffer( buffer, faces, verts )
		{
			function addTriangleToBuffer( buffer, bi, vals, i, j, k )
			{
				buffer[bi++] = vals[i].x;
				buffer[bi++] = vals[i].y;
				buffer[bi++] = vals[i].z;
				buffer[bi++] = vals[j].x;
				buffer[bi++] = vals[j].y;
				buffer[bi++] = vals[j].z;
				buffer[bi++] = vals[k].x;
				buffer[bi++] = vals[k].y;
				buffer[bi++] = vals[k].z;
			}
			for ( var i=0, bi=0; i<faces.length; ++i ) {
				var f = faces[i];
				if ( f.length < 3 ) continue;
				addTriangleToBuffer( buffer, bi, verts, f[0], f[1], f[2] );
				bi += 9;
				for ( var j=3; j<f.length; ++j, bi+=9 ) {
					addTriangleToBuffer( buffer, bi, verts, f[0], f[j-1], f[j] );
				}
			}
		}
		
		// update the position buffer
		updateBuffer( this.buffers.positionBuffer, this.mesh.face, this.pos );
		
		// update normals
		for ( var i=0; i<this.nrm.length; ++i ) this.nrm[i].init(0,0,0);
		for ( var i=0; i<this.mesh.face.length; ++i ) {
			var f = this.mesh.face[i];
			var nf = this.mesh.nfac[i];
			var v0 = this.pos[ f[0] ];
			for ( var j=1; j<f.length-1; ++j ) {
				var v1 = this.pos[ f[j] ];
				var v2 = this.pos[ f[j+1] ];
				var e0 = v1.sub(v0);
				var e1 = v2.sub(v0);
				var n  = e0.cross(e1);
				n = n.unit();
				this.nrm[ nf[0  ] ].inc(n);
				this.nrm[ nf[j  ] ].inc(n);
				this.nrm[ nf[j+1] ].inc(n);
			}
		}
		for ( var i=0; i<this.nrm.length; ++i ) this.nrm[i].normalize();
		updateBuffer( this.buffers.normalBuffer, this.mesh.nfac, this.nrm );

		this.meshDrawer.setMesh( this.buffers.positionBuffer, this.buffers.texCoordBuffer, this.buffers.normalBuffer );

		DrawScene();
	}
	simTimeStep() {
		let flagCollision = false;
		let boundingBoxes = [];

		// Ricorda la posizione del vertice selezionato, se presente
		var p = this.holdVert ? this.holdVert.copy() : undefined;

		UpdateProjectionMatrix();

		// Aggiorna posizioni e velocità
		var timestep = 10;
		const dt = timestep / 1000;  // time step in seconds
		const damping = this.damping * this.stiffness * dt;

		let cBoundingBox = this.currentBoundingBox();
		for (let i = 0; i < massSprings.length; i++) {
			if (massSprings[i] !== this && !(massSprings[i] instanceof Floor)) {
				let otherBoundingBox = massSprings[i].currentBoundingBox();
				if (detectAABBCollision(cBoundingBox, otherBoundingBox)) {
					flagCollision = true;
					boundingBoxes.push(otherBoundingBox);  // Aggiungi la bounding box rilevata
				}
			}
		}

		if (flagCollision && this instanceof Ball) {
			this.gravity.y = 0;
		}

		// SimTimeStep(dt, this.pos, this.vel, this.springs, this.stiffness, damping, this.mass, this.gravity, this.restitution, flagCollision, boundingBoxes);

		SimTimeStep_Verlet(dt, this.pos, this.prevPos,this.vel, this.springs, this.stiffness, damping, this.mass, this.gravity, this.restitution, flagCollision, boundingBoxes)

		// SimTimeStep_ImplicitEuler(dt, this.pos, this.vel, this.springs, this.stiffness, damping, this.mass, this.gravity, this.restitution, flagCollision, boundingBoxes);

		if (p) {
			this.holdVert.set(p);
			this.vel[this.selVert].init(0, 0, 0);
		}

		this.updateMesh();
	}


	startSimulation() {
		var timestep = 10;
		if (!this.isSimulationRunning()) {
			
			this.timer = setInterval(function() {
				for (let i = 0; i < massSprings.length; i++) {
					massSprings[i].simTimeStep();
				}
			}, timestep);
		}
	}

	stopSimulation()
	{
		clearInterval( this.timer );
		this.timer = undefined;
	}
	isSimulationRunning() { return this.timer !== undefined; }
	restartSimulation() { if ( this.isSimulationRunning() ) { this.stopSimulation(); this.startSimulation(); } }
	toggleSimulation( btn )
	{
		if ( this.isSimulationRunning() ) {
			this.stopSimulation();
			btn.value = "Start Simulation";
		} else {
			this.startSimulation();
			btn.value = "Stop Simulation";
		}
	}
	
	mouseMove()
	{
		var m = MousePos();
		this.selVert = undefined;
		var selPt;
		var minDist = 10;
		for ( var i=0; i<this.pos.length; ++i ) {
			var p = this.pos[i];
			if (!MVP) {
				continue;
			}
			var pv = p.trans(MVP);
			var px = pv.x / pv.w;
			var py = pv.y / pv.w;
			var dx = m.x - px;
			var dy = m.y - py;
			var len2 = dx*dx + dy*dy;
			if ( len2 < 0.001 && len2 < minDist ) {
				minDist = len2;
				this.selVert = i;
				selPt = p;
			}
		}
	}
	
	mouseDown()
	{
		if ( this.selVert === undefined ) return false;
		var mInv = MatrixInverse(MVP);
		var p = this.pos[ this.selVert ];
		var pv = p.trans(MVP);
		this.holdVert = this.pos[ this.selVert ];
		
		function mouse4D()
		{
			var m = MousePos();
			return {
				x: m.x * pv.w,
				y: m.y * pv.w,
				z: pv.z,
				w: pv.w
			};
		}
		
		function invTrans(v)
		{
			return {
				x: mInv[0]*v.x + mInv[4]*v.y + mInv[ 8]*v.z + mInv[12]*v.w,
				y: mInv[1]*v.x + mInv[5]*v.y + mInv[ 9]*v.z + mInv[13]*v.w,
				z: mInv[2]*v.x + mInv[6]*v.y + mInv[10]*v.z + mInv[14]*v.w,
				w: mInv[3]*v.x + mInv[7]*v.y + mInv[11]*v.z + mInv[15]*v.w
			};
		}
		
		function mouse3D() { 
			var m = invTrans(mouse4D());
			return new Vec3( m.x/m.w, m.y/m.w, m.z/m.w );
		}
		
		var m0 = mouse3D();
		var ms = this;
		
		canvas.onmousemove = function() {
			var m1 = mouse3D();
			var d = m1.sub(m0);
			m0 = { ...m1 };
			p.inc(d);
			ms.updateMesh();
		}
		return true;		
	}
	
	mouseUp()
	{
		this.holdVert = undefined;
	}
}

class Pin extends MassSpring {
    constructor(objdef, initialPosition) {
        super(objdef, initialPosition);
        this.mass = 0.2;
        this.stiffness = 1;
        this.damping = 1;
        this.restitution = 0.8;
    }
}

class Ball extends MassSpring {
    constructor(objdef, initialPosition) {
        super(objdef, initialPosition);
		this.gravity = new Vec3( 0, -2, 0 );
        this.mass = 0.2;
        this.stiffness = 1;
        this.damping = 1;
        this.restitution = 0.8;
    }
}

class Floor extends MassSpring {
    constructor(objdef, initialPosition) {
        super(objdef, initialPosition);
		this.gravity = new Vec3( 0, -2, 0 );
        this.mass = 0.2;
        this.stiffness = 1;
        this.damping = 1;
        this.restitution = 0.8;
    }

	simTimeStep() {
		// il pavimento non si muove
	}
}


///////////////////////////////////////////////////////////////////////////////////
</script>

<script type="text/javascript">
	///////////////////////////////////////////////////////////////////////////////////
	// Below is the light view control code
	///////////////////////////////////////////////////////////////////////////////////
	
	var lightView;
	
	class LightView
	{
		constructor()
		{
			this.canvas = document.getElementById("lightcontrol");
			this.canvas.oncontextmenu = function() {return false;};
			this.gl = this.canvas.getContext("webgl", {antialias: false, depth: true});	// Initialize the GL context
			if (!this.gl) {
				alert("Unable to initialize WebGL. Your browser or machine may not support it.");
				return;
			}
			
			// Initialize settings
			this.gl.clearColor(0.33,0.33,0.33,0);
			this.gl.enable(gl.DEPTH_TEST);
			
			this.rotX = 0;
			this.rotY = 0;
			this.posZ = 5;
			
			this.resCircle = 32;
			this.resArrow = 16;
			this.buffer = this.gl.createBuffer();
			var data = [];
			for ( var i=0; i<=this.resCircle; ++i ) {
				var a = 2 * Math.PI * i / this.resCircle;
				var x = Math.cos(a);
				var y = Math.sin(a);
				data.push( x * .9 );
				data.push( y * .9 );
				data.push( 0 );
				data.push( x );
				data.push( y );
				data.push( 0 );
			}
			for ( var i=0; i<=this.resCircle; ++i ) {
				var a = 2 * Math.PI * i / this.resCircle;
				var x = Math.cos(a);
				var y = Math.sin(a);
				data.push( x );
				data.push( y );
				data.push( -.05 );
				data.push( x );
				data.push( y );
				data.push( 0.05 );
			}
			for ( var i=0; i<=this.resArrow; ++i ) {
				var a = 2 * Math.PI * i / this.resArrow;
				var x = Math.cos(a) * .07;
				var y = Math.sin(a) * .07;
				data.push( x );
				data.push( y );
				data.push( -1 );
				data.push( x );
				data.push( y );
				data.push( 0 );
			}
			data.push( 0 );
			data.push( 0 );
			data.push( -1.2 );
			for ( var i=0; i<=this.resArrow; ++i ) {
				var a = 2 * Math.PI * i / this.resArrow;
				var x = Math.cos(a) * .15;
				var y = Math.sin(a) * .15;
				data.push( x );
				data.push( y );
				data.push( -0.9 );
			}
			this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
			this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(data), this.gl.STATIC_DRAW);
			
			// Set the viewport size
			this.canvas.style.width  = "";
			this.canvas.style.height = "";
			const pixelRatio = window.devicePixelRatio || 1;
			this.canvas.width  = pixelRatio * this.canvas.clientWidth;
			this.canvas.height = pixelRatio * this.canvas.clientHeight;
			const width  = (this.canvas.width  / pixelRatio);
			const height = (this.canvas.height / pixelRatio);
			this.canvas.style.width  = width  + 'px';
			this.canvas.style.height = height + 'px';
			this.gl.viewport( 0, 0, this.canvas.width, this.canvas.height );
			UpdateProjectionMatrix();
			this.proj = perspectiveMatrix;
			
			// Compile the shader program
			this.prog = InitShaderProgram( lightViewVS, lightViewFS, this.gl );
			this.mvp = this.gl.getUniformLocation( this.prog, 'mvp' );
			this.clr1 = this.gl.getUniformLocation( this.prog, 'clr1' );
			this.clr2 = this.gl.getUniformLocation( this.prog, 'clr2' );
			this.vertPos = this.gl.getAttribLocation( this.prog, 'pos' );
			
			this.draw();
			this.updateLightDir();
			
			this.canvas.onmousedown = function() {
				var cx = event.clientX;
				var cy = event.clientY;
				lightView.canvas.onmousemove = function() {
					lightView.rotY += (cx - event.clientX)/lightView.canvas.width*5;
					lightView.rotX += (cy - event.clientY)/lightView.canvas.height*5;
					cx = event.clientX;
					cy = event.clientY;
					lightView.draw();
					lightView.updateLightDir();
				}
			}
			this.canvas.onmouseup = this.canvas.onmouseleave = function() {
				lightView.canvas.onmousemove = null;
			}
		}
		
		updateLightDir()
		{
			var cy = Math.cos( this.rotY );
			var sy = Math.sin( this.rotY );
			var cx = Math.cos( this.rotX );
			var sx = Math.sin( this.rotX );
			for (var i=0; i<massSprings.length; ++i){ 
				massSprings[i].meshDrawer.setLightDir( -sy, cy*sx, -cy*cx );
			}
			DrawScene();
		}
		
		draw()
		{
			// Clear the screen and the depth buffer.
			this.gl.clear( this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT );
			
			this.gl.bindBuffer( this.gl.ARRAY_BUFFER, this.buffer );
			this.gl.vertexAttribPointer( this.vertPos, 3, this.gl.FLOAT, false, 0, 0 );
			this.gl.enableVertexAttribArray( this.buffer );
	
			this.gl.useProgram( this.prog );
			var mvp = MatrixMult( this.proj, [ 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,this.posZ,1 ] );
			this.gl.uniformMatrix4fv( this.mvp, false, mvp );
			this.gl.uniform3f( this.clr1, 0.6,0.6,0.6 );
			this.gl.uniform3f( this.clr2, 0,0,0 );
			this.gl.drawArrays( this.gl.TRIANGLE_STRIP, 0, this.resCircle*2+2 );
	
			var mv  = GetModelViewMatrix( 0, 0, this.posZ, this.rotX, this.rotY );
			var mvp = MatrixMult( this.proj, mv );
			this.gl.uniformMatrix4fv( this.mvp, false, mvp );
			this.gl.uniform3f( this.clr1, 1,1,1 );
			this.gl.drawArrays( this.gl.TRIANGLE_STRIP, 0, this.resCircle*2+2 );
			this.gl.drawArrays( this.gl.TRIANGLE_STRIP, this.resCircle*2+2, this.resCircle*2+2 );
			this.gl.uniform3f( this.clr1, 0,0,0 );
			this.gl.uniform3f( this.clr2, 1,1,1 );
			this.gl.drawArrays( this.gl.TRIANGLE_STRIP, this.resCircle*4+4, this.resArrow*2+2 );
			this.gl.drawArrays( this.gl.TRIANGLE_FAN, this.resCircle*4+4 + this.resArrow*2+2, this.resArrow+2 );
		}
	}
		
	///////////////////////////////////////////////////////////////////////////////////
</script>
	

<script id="collision" type="text/javascript">
///////////////////////////////////////////////////////////////////////////////////
// Collision
///////////////////////////////////////////////////////////////////////////////////
function detectAABBCollision(boxA, boxB) {

    if (boxA instanceof Floor || boxB instanceof Floor) {
        return false;
    }

    return (boxA.min.x <= boxB.max.x && boxA.max.x >= boxB.min.x) &&
           (boxA.min.y <= boxB.max.y && boxA.max.y >= boxB.min.y) &&
           (boxA.min.z <= boxB.max.z && boxA.max.z >= boxB.min.z);
}

///////////////////////////////////////////////////////////////////////////////////
</script>

<script id="UI" type="text/javascript">
///////////////////////////////////////////////////////////////////////////////////
// Below are the main UI control functions.
///////////////////////////////////////////////////////////////////////////////////

window.onload = function() {
	InitWebGL();
	lightView = new LightView();

	canvas.zoom = function( s ) 
	{
		transZ *= s/canvas.height + 1;
		UpdateProjectionMatrix();
		DrawScene();
	}
	canvas.onwheel = function() 
	{ 
		canvas.zoom(0.3*event.deltaY); 
	}
	canvas.onmousedown = function() 
	{
		let handled = false;

		// Loop through all massSprings and check if any of them handle the mouse down event
		for (let i = 0; i < massSprings.length; i++) {
			if (massSprings[i].mouseDown()) {
				handled = true;
				break; // Stop looping if one of the objects handles the event
			}
		}

		if (handled) {
			canvas.ondblclick = null;
			return;
		}

		// If no object handled the mouse down event, proceed with the view controls
		canvas.ondblclick = canvas.resetView;
		var cx = event.clientX;
		var cy = event.clientY;
		if (event.ctrlKey) {
			canvas.onmousemove = function() {
				canvas.zoom(5 * (event.clientY - cy));
				cy = event.clientY;
			}
		} else if (event.altKey) {
			canvas.onmousemove = function() {
				let s = 1.5 * transZ * (event.clientY - cy);
				transY -= s / canvas.height;

				UpdateProjectionMatrix();				
				DrawScene();
				cy = event.clientY;
			}
		} else {
			canvas.onmousemove = function() {
				rotY += (cx - event.clientX) / canvas.width * 5;
				rotX += (cy - event.clientY) / canvas.height * 5;
				cx = event.clientX;
				cy = event.clientY;
				UpdateProjectionMatrix();
				DrawScene();
			}
		}
	}
	canvas.onmouseup = canvas.onmouseleave = function() 
	{
		for (let i = 0; i < massSprings.length; i++) {
			massSprings[i].mouseUp();
		}
	
		canvas.onmousemove = function() {
			for (let i = 0; i < massSprings.length; i++) {
				if (MVP) {
					massSprings[i].mouseMove();
				}
			}
		}
	}

	canvas.onmousemove = function() {
		// Loop through all massSprings and call mouseMove on each
		for (let i = 0; i < massSprings.length; i++) {
			massSprings[i].mouseMove();
		}
	}

	canvas.resetView = function() {
		rotX = 0;
		rotY = 0;
		transY = 0;
		transZ = 40;
		UpdateProjectionMatrix();
		DrawScene();
	}


	SetGravity  ( document.getElementById('gravity') );
	SetMass     ( document.getElementById('mass') );
	SetStiffness( document.getElementById('stiffness') );
	SetDamping  ( document.getElementById('damping') );

	SetShininess( document.getElementById('shininess-exp') );

	DrawScene();
};

function InitShaderProgramFromScripts( vs, fs )
{
	return InitShaderProgram( document.getElementById(vs).text, document.getElementById(fs).text );	
}

function WindowResize()
{
	UpdateCanvasSize();
	DrawScene();
}

function MousePos()
{
	return {
		x:  ( event.clientX / canvas.clientWidth  ) * 2 - 1,
		y: -( event.clientY / canvas.clientHeight ) * 2 + 1
	};
}

function ShowTexture( param )
{
	for (let i = 0; i < massSprings.length; i++) {
		massSprings[i].meshDrawer.showTexture( param.checked );
	}
	DrawScene();
}

function LoadTexturesForObjects(objects) {
    objects.forEach(function(object) {
        var img = new Image();
        img.onload = function() {
            object.meshDrawer.setTexture(img);
            DrawScene();
        };

        if (object instanceof Floor) {
			img.src = 'Textures/floorTEX.png';
        } else if (object instanceof Ball) {
            img.src = 'Textures/ballTEX.png';
        } else if (object instanceof Pin) {
            img.src = 'Textures/pinTEX.png';
        } else {
            console.error('Tipo di oggetto non riconosciuto:', object);
        }
    });
}

function SetGravity(param) 
{
    var v = param.value;
    var s = v / 20;
    document.getElementById('gravity-value').innerText = s.toFixed(2);
    for (let i = 0; i < massSprings.length; i++) {
        massSprings[i].gravity.y = (-s);
    }
}

function SetMass(param) 
{
    var v = param.value;
    var s = v / 200;
	document.getElementById('mass-value').innerText = s.toFixed(3);

    // Loop through all massSprings and set the mass for each
    for (let i = 0; i < massSprings.length; i++) 
	{
        massSprings[i].mass = s;
    }
}

function SetStiffness(param) 
{
    var v = param.value;
    var s = v / 20;
    document.getElementById('stiffness-value').innerText = s.toFixed(2);

    // Loop through all massSprings and set the stiffness for each
    for (let i = 0; i < massSprings.length; i++) 
	{
        massSprings[i].stiffness = s;
    }
}

function SetDamping(param)
{
    var v = param.value;
    var s = v / 20;
    document.getElementById('damping-value').innerText = s.toFixed(2);

    // Loop through all massSprings and set the damping for each
    for (let i = 0; i < massSprings.length; i++) {
        massSprings[i].damping = s;
    }
}

function SetShininess( param )
{
	var exp = param.value;
	var s = Math.pow(10,exp/25);
	document.getElementById('shininess-value').innerText = s.toFixed( s < 10 ? 2 : 0 );
	for (let i = 0; i < massSprings.length; i++) {
		massSprings[i].meshDrawer.setShininess(s);
	}
	DrawScene();
}

function disableMouseInteractions() 
{
    canvas.onmousemove = null;  
    canvas.onmousedown = null;  
    canvas.onmouseup = null;    
    canvas.onmouseleave = null;
    canvas.onwheel = null;      
}

function enableMouseInteractions() 
{

	canvas.zoom = function( s ) 
	{
		transZ *= s/canvas.height + 1;
		UpdateProjectionMatrix();
		DrawScene();
	}
	
	canvas.onwheel = function() 
	{ 
		canvas.zoom(0.3*event.deltaY); 
	}

	canvas.onmousedown = function() 
	{
		let handled = false;

		// Loop through all massSprings and check if any of them handle the mouse down event
		for (let i = 0; i < massSprings.length; i++) 
		{
			if (massSprings[i].mouseDown()) 
			{
				handled = true;
				break; // Stop looping if one of the objects handles the event
			}
		}

		if (handled) 
		{
			canvas.ondblclick = null;
			return;
		}

		// If no object handled the mouse down event, proceed with the view controls
		canvas.ondblclick = canvas.resetView;
		var cx = event.clientX;
		var cy = event.clientY;
		if (event.ctrlKey) 
		{
			canvas.onmousemove = function() 
			{
				canvas.zoom(5 * (event.clientY - cy));
				cy = event.clientY;
			}
		} else if (event.altKey) 
		{
			canvas.onmousemove = function() 
			{
				let s = 1.5 * transZ * (event.clientY - cy);
				transY -= s / canvas.height;

				UpdateProjectionMatrix();				
				DrawScene();
				cy = event.clientY;
			}
		} else 
		{
			canvas.onmousemove = function() 
			{
				rotY += (cx - event.clientX) / canvas.width * 5;
				rotX += (cy - event.clientY) / canvas.height * 5;
				cx = event.clientX;
				cy = event.clientY;
				UpdateProjectionMatrix();
				DrawScene();
			}
		}
	}

	canvas.onmouseup = canvas.onmouseleave = function() 
	{
		for (let i = 0; i < massSprings.length; i++) 
		{
			massSprings[i].mouseUp();
		}
	
		canvas.onmousemove = function() {
			for (let i = 0; i < massSprings.length; i++) 
			{
				if (MVP) {
					massSprings[i].mouseMove();
				}
			}
		}
	}

	canvas.onmousemove = function() {
		for (let i = 0; i < massSprings.length; i++) {
			massSprings[i].mouseMove();
		}
	}

	canvas.resetView = function() {
		rotX = 0;
		rotY = 0;
		transY = 0;
		transZ = 40;
		UpdateProjectionMatrix();
		DrawScene();
	}
}

function stopPlay() {
	
	console.log("stopPlay");

	enableMouseInteractions();

	for (let i = 0; i < massSprings.length; i++) {
		massSprings[i].stopSimulation();
	}

	document.removeEventListener('keydown', keydownListenerMove);
    document.removeEventListener('keydown', keydownListenerSimulate);
}

// Oggetto che incapsula la logica della barra di potenza
const PowerBar = {
    isRunning: false,
    direction: 1, // Indica se la barra sta andando su (+1) o giù (-1)
    value: 0, // Rappresenta la posizione della barra (0 a 100)
    interval: null, // Riferimento all'intervallo di aggiornamento
    strength: 0, // Valore finale della potenza
    currentColor: 'green', // Colore corrente della barra
    
    // Inizia la barra di potenza
    start: function() {
        const powerIndicator = document.getElementById('powerIndicator');
        const powerBar = document.getElementById('powerBar');
        this.isRunning = true;

        // Mostra la barra
        powerIndicator.style.display = 'block';

        // Intervallo per far muovere la barra su e giù
		this.interval = setInterval(() => {
			if (this.value >= 100) {
				this.direction = -1;
			} else if (this.value <= 0) {
				this.direction = 1;
			}

			// Aggiorna il valore della barra
			this.value += this.direction * 2;

			// Cambia il colore in base al valore
			if (this.value > 80) {
				powerBar.style.backgroundColor = 'red';
				this.currentColor = 'red';
			} else if (this.value < 30) {
				powerBar.style.backgroundColor = 'green';
				this.currentColor = 'green';
			} else {
				powerBar.style.backgroundColor = 'yellow';
				this.currentColor = 'yellow';
			}

			// Aggiorna l'altezza della barra per riflettere il valore corrente
			powerBar.style.height = this.value + '%';
		}, 50);
    },

    // Ferma la barra e determina la forza del tiro
    stop: function() {
        clearInterval(this.interval);
        this.isRunning = false;
        return this.value;
    },

    // Nasconde la barra di potenza dopo il tiro
    hide: function() {
        document.getElementById('powerIndicator').style.display = 'none';
    }
};


const Arrows = {
    
    // Inizia la barra di potenza
    start: function() {
        const leftArrow = document.querySelector('.arrow-left');
        const rightArrow = document.querySelector('.arrow-right');

        if (!leftArrow || !rightArrow) {
            console.error('Le frecce non sono state trovate nel DOM');
            return;
        }

		leftArrow.style.display = 'block';
        rightArrow.style.display = 'block';

		renderArrows();
    },

    update: function(border) {
        clearInterval(this.interval);
        this.isRunning = false;

		renderArrows(border);
    },

    // Nasconde la barra di potenza dopo il tiro
    stop: function() {
        document.querySelector('.arrow-left').style.display = 'none';
        document.querySelector('.arrow-right').style.display = 'none';
        document.getElementById('powerIndicator').style.display = 'none';
    }
};

// Funzione per far partire la transizione della camera
function startCameraTransition(startPos, endPos, duration, onComplete) {
    let startTime = null;

    function animateCamera(timestamp) {
        if (!startTime) startTime = timestamp;
        const elapsedTime = timestamp - startTime;
        const t = Math.min(elapsedTime / duration, 1); // Normalizza il tempo (0-1)

        // Interpolazione lineare (lerp) delle posizioni
        transY = startPos.y + (endPos.y - startPos.y) * t;
        transZ = startPos.z + (endPos.z - startPos.z) * t;

        rotX = startPos.rotX + (endPos.rotX - startPos.rotX) * t;
        rotY = startPos.rotY + (endPos.rotY - startPos.rotY) * t;

        UpdateProjectionMatrix();
        DrawScene();

        if (t < 1) {
            requestAnimationFrame(animateCamera); // Continua l'animazione
        } else if (onComplete) {
            onComplete(); // Esegui callback quando l'animazione è completa
        }
    }

    requestAnimationFrame(animateCamera);
}

// Funzione per avviare la simulazione e la barra di potenza
function startPlay() {
    console.log("startPlay");

    isPlaying = false;

    const initialPos = { x: 0, y: transY, z: transZ, rotX: rotX, rotY: rotY };
    const finalPos = { x: 0, y: 0, z: 12, rotX: -0.2, rotY: 0 }; // Posizione finale desiderata
    const transitionDuration = 2000; // Durata della transizione in millisecondi (2 secondi)

    disableMouseInteractions();

    startCameraTransition(initialPos, finalPos, transitionDuration, () => 
	{
		Arrows.start();
		PowerBar.start();

		keydownListenerMove = (e) => {  
			if (!isPlaying) {  
				let bowlingBall = massSprings.find(item => item instanceof Ball);  
				if (bowlingBall) {  
					const boundingBox = bowlingBall.currentBoundingBox();  
					const laneWidth = 5;  // Definisci la larghezza della corsia  

					// Movimento sinistra-destra
					if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {  
						console.log("left-right")  
						let direction = e.key === 'ArrowLeft' ? -0.1 : 0.1;  
						
						var border;  
						if ((boundingBox.min.x + direction) > -laneWidth / 2 &&  
							(boundingBox.max.x + direction) < laneWidth / 2) {  

							if ((boundingBox.min.x + direction) - (-laneWidth / 2) <= 0.1) {  
								console.log("La palla è vicino al bordo sinistro della corsia!");  
								border = "left";  
							} else if ((laneWidth / 2 - (boundingBox.max.x + direction)) <= 0.1) {  
								console.log("La palla è vicino al bordo destro della corsia!");  
								border = "right";  
							} else {  
								border = "none";  
							}  

							for (let i = 0; i < bowlingBall.pos.length; i++) {  
								bowlingBall.pos[i].x += direction;  
							}  

							Arrows.update(border);  
							bowlingBall.updateMesh();  
							UpdateProjectionMatrix();  
							DrawScene();  
						} else {  
							console.log("La palla sta uscendo dai limiti della corsia!");  
						}  
					}  
				}  
			}  
		};  

		// Listener per avviare il tiro senza dipendere dal movimento sinistra-destra
		keydownListenerSimulate = (e) => {  
			if (e.key === 'ArrowUp') {  
				var power = PowerBar.stop();  
				console.log("Power: " + power);  
				shoot(power);  
				Arrows.stop();  
				startSimulation();  // Inizia il tiro  
			}  
		};  

		// Aggiungi il listener per il tiro indipendentemente dal movimento sinistra-destra
		document.addEventListener('keydown', keydownListenerSimulate);

		// Aggiungi il listener per il movimento sinistra-destra
		document.addEventListener('keydown', keydownListenerMove);

		document.addEventListener('keydown', keydownListenerMove);
    });
}

function shoot(power)
{
	var ball = massSprings.find(item => item instanceof Ball);
		
	for (let i = 0; i < ball.pos.length; i++) 
	{
		ball.gravity.z = power/100 * 1;
	}

}

// Funzione per avviare la simulazione del tiro
function startSimulation() {
    console.log("Inizio della simulazione");

    isPlaying = true;

    for (let i = 0; i < massSprings.length; i++) {
        massSprings[i].startSimulation();
    }
}

function toggleSimulation(button) {
	
	if (isPlaying) {
		isPlaying = false;
		stopPlay();
		button.value = "Start Play";
	} else {
		isPlaying = true;
		startPlay();
		button.value = "Stop Play";
	}
    
}

function resetAll() {
    for (let i = 0; i < massSprings.length; i++) {
        massSprings[i].reset();
    }	

	document.querySelector('.arrow-left').style.display = 'none';
    document.querySelector('.arrow-right').style.display = 'none';
	document.getElementById('powerIndicator').style.display = 'none';

    isPlaying = false;

	canvas.ondblclick = canvas.resetView;
}


function restartAllSimulations() {
    for (let i = 0; i < massSprings.length; i++) {
        massSprings[i].restartSimulation();
    }
}

function NewScene() {
	DrawScene();
}

///////////////////////////////////////////////////////////////////////////////////
</script>

<script id="arrow" type="text/javascript">

	function projectPoint(point) 
	{
		// Moltiplica il punto per la matrice MVP
		var x = point[0], y = point[1], z = point[2], w = 1;
		var px = MVP[0] * x + MVP[4] * y + MVP[8]  * z + MVP[12] * w;
		var py = MVP[1] * x + MVP[5] * y + MVP[9]  * z + MVP[13] * w;
		var pz = MVP[2] * x + MVP[6] * y + MVP[10] * z + MVP[14] * w;
		var pw = MVP[3] * x + MVP[7] * y + MVP[11] * z + MVP[15] * w;

		// Effettua la proiezione prospettica (divide per w)
		if (pw != 0) {
			px /= pw;
			py /= pw;
			pz /= pw;
		}

		// Trasforma le coordinate normalizzate dello spazio clip in coordinate dello schermo
		var screenX = (px + 1) * 0.5 * canvas.width;
		var screenY = (1 - py) * 0.5 * canvas.height;

		return [screenX, screenY, pz];
	}

	function renderArrows(border = "none") {
		// Trova la palla all'interno di massSprings
		let ball = massSprings.find(item => item instanceof Ball);
		if (!ball) {
			console.error('Palla non trovata');	
			return;
		}

		// Ottieni il bounding box della palla
		const boundingBox = ball.currentBoundingBox();

		// Calcola la posizione delle frecce rispetto ai bordi della palla
		const leftArrowPosition = [boundingBox.min.x, boundingBox.min.y, boundingBox.min.z];
		const rightArrowPosition = [boundingBox.max.x, boundingBox.min.y, boundingBox.min.z];

		// Definiamo le variabili per le posizioni delle frecce proiettate
		let leftArrowScreenPos, rightArrowScreenPos;

		// Ottieni gli elementi freccia dal DOM
		const leftArrow = document.querySelector('.arrow-left');
		const rightArrow = document.querySelector('.arrow-right');

		// Semplifichiamo i controlli in base al parametro `border`
		if (border === "left") {
			// Nascondi la freccia sinistra perché siamo al bordo sinistro
			leftArrow.style.display = 'none';
			// Proietta e posiziona solo la freccia destra
			rightArrowScreenPos = projectPoint(rightArrowPosition);
		} else if (border === "right") {
			// Nascondi la freccia destra perché siamo al bordo destro
			rightArrow.style.display = 'none';
			// Proietta e posiziona solo la freccia sinistra
			leftArrowScreenPos = projectPoint(leftArrowPosition);
		} else {
			// Nessun bordo, mostra entrambe le frecce
			leftArrow.style.display = 'block';
			rightArrow.style.display = 'block';
			// Proietta entrambe le frecce
			leftArrowScreenPos = projectPoint(leftArrowPosition);
			rightArrowScreenPos = projectPoint(rightArrowPosition);
		}

		// Posiziona le frecce sul canvas in base alle coordinate 2D
		if (leftArrowScreenPos) {
			leftArrow.style.left = leftArrowScreenPos[0] - leftArrow.offsetWidth + 'px';
			leftArrow.style.top = leftArrowScreenPos[1] + 'px';
		}

		if (rightArrowScreenPos) {
			rightArrow.style.left = rightArrowScreenPos[0] + 'px';
			rightArrow.style.top = rightArrowScreenPos[1] + 'px';
		}
	}




</script>



</head>
<body onresize="WindowResize()">
<div id="canvas-div"><canvas id="canvas"></canvas></div><div id="controls-div">
<div id="controls">
<div class="control-group">
	<canvas id="lightcontrol"></canvas><div id="lightcontrol-label">Light Direction</div></div>
<div class="control-group">
	<div class="control"><input type="button" value="Start Play" onclick="toggleSimulation(this)"></div>
	<div class="control"><input type="button" value="Reset" onclick="resetAll(); DrawScene();"></div>
		
	<div class="control"><span id="gravity-label">Gravity:</span><span class="value" id="gravity-value">1</span><input id="gravity" type="range" min="0" max="100" value="20" oninput="SetGravity(this)" ondblclick="this.value=20;this.oninput()"/></div>
	
	<div class="control"><span id="mass-label">Mass:</span><span class="value" id="mass-value">1</span><input id="mass" type="range" min="1" max="100" value="20" oninput="SetMass(this)" ondblclick="this.value=20;this.oninput()"/></div>

	<div class="control"><span id="stiffness-label">Stiffness:</span><span class="value" id="stiffness-value">1</span><input id="stiffness" type="range" min="0" max="100" value="20" oninput="SetStiffness(this)" ondblclick="this.value=20;this.oninput()"/></div>
	
	<div class="control"><span id="damping-label">Damping:</span><span class="value" id="damping-value">1.00</span><input id="damping" type="range" min="0" max="100" value="20" oninput="SetDamping(this)" ondblclick="this.value=20;this.oninput()"/></div>	
</div>
<div class="control-group">
	<div class="control"><span id="shininess-label">Shininess:</span><span class="value" id="shininess-value">1</span><input id="shininess-exp" type="range" min="0" max="100" value="50" oninput="SetShininess(this)" ondblclick="this.value=50;this.oninput()"/></div>

	<div class="control"><input id="show-texture" name="show-texture" type="checkbox" onchange="ShowTexture(this)" /><label for="show-texture"> Show Texture</label></div>
	
	<div class="control"><img id="texture-img" /></div>
</div>
</div>
</div>
<div id="powerIndicator" style="display: none;">
    <label id="powerLabel"></label>
    <div id="powerBarContainer" style="width: 100px; height: 400px; background-color: grey; position: relative;">
        <div id="powerBar" style="width: 100%; height: 0%; background-color: green; position: absolute; bottom: 0;"></div>
    </div>
</div>
<div class="arrow-left"></div>
<div class="arrow-right"></div>





</body>
</html>